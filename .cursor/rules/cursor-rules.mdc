### General Steps
1.  **Centralize Data**: Define data structures and initial data in a dedicated file (e.g., `data/users.ts`).
2.  **Expose Data Access/Modification Functions**: Provide functions (e.g., `getUsers`, `addUser`, `updateUser`, `deleteUser`) that encapsulate data operations. For mock data, this means exporting mutable state and setter functions.
3.  **Component State & Props**: Components displaying data should receive it via props or consume it from a central store. Components modifying data should pass changes up via callbacks or dispatch actions to a central store.
4.  **Reactivity**: Ensure that changes to the centralized data automatically re-render dependent components. This typically involves using React's `useState` or `useContext` hooks, or a state management library.

### Example Application (User Management)
* **`data/users.ts`**: Will export `users` array and a `setUsers` function (or similar) to allow external modification of the user list.
* **`users-table.tsx`**: Will receive the `users` data as a prop and use internal state (e.g., `currentPage`) to manage display logic. It will call functions (passed as props) to trigger CRUD operations on the central `users` data.
* **`page.tsx` (or parent component)**: Will hold the primary `users` state and pass it down. It will also define the `handleCreateUser`, `handleUpdateUser`, `handleDeleteUser`, `handleDeactivateUser`, `handleActivateUser` functions that modify this central state and pass them as callbacks to `UsersTable` and `CreateUserDialog`.

---

## Rule: Reusable Form Components and Validation

### Description
Forms for creating or editing data should leverage a consistent approach for state management, validation, and submission. `react-hook-form` with `zod` resolver is the preferred choice for robust form handling and validation. Dialogs should be used for user input when appropriate.

### General Steps
1.  **Schema Definition**: Define validation schemas using `zod` for each form (e.g., `createUserSchema`).
2.  **Form Hook**: Utilize `useForm` from `react-hook-form` with the `zodResolver`.
3.  **Controlled Inputs**: Bind form fields to `react-hook-form` using `FormField`, `FormControl`, etc.
4.  **Error Handling**: Display validation messages using `FormMessage`.
5.  **Reusability**: Design form components (like dialogs) to be reusable for both creation and editing by accepting optional `initialData` or an `editing` prop.

### Example Application (Create/Edit User Dialog)
* **`create-user-dialog.tsx`**: This component will be made generic enough to handle both "create" and "edit" operations.
    * It will accept an optional `editingUser: UserInterface | null` prop.
    * `defaultValues` for `useForm` will be conditionally set based on `editingUser`.
    * The `onSubmit` logic will differentiate between creating a new user (if `editingUser` is null) and updating an existing one (if `editingUser` is provided).
    * It will include `zod` schema for validation (already present).

---

## Rule: Consistent Modals/Dialogs for User Confirmation

### Description
Actions that result in data modification (e.g., deletion, deactivation, activation) or require user input should use AlertDialogs or Dialogs from `@/components/ui` for confirmation or data entry. Each dialog should clearly state the action and its implications.

### General Steps
1.  **State for Dialog Control**: Use `useState` to control the open/closed state of each dialog.
2.  **Clear Titles and Descriptions**: Ensure `AlertDialogTitle` and `AlertDialogDescription` clearly communicate the purpose and impact of the action.
3.  **Confirmation Actions**: Implement `AlertDialogAction` to trigger the actual data modification, and `AlertDialogCancel` to close the dialog without action.

### Example Application (Deactivate, Delete, Activate User Dialogs)
* **`users-table.tsx`**: Already implements this for deactivation, deletion, and activation. Ensure the `confirm...` functions correctly call the parent component's (or global state's) functions to perform the actual data manipulation.

---

## Rule: Action-Oriented UI Elements

### Description
Interactive elements (buttons, dropdown menus) should clearly indicate their purpose and trigger the appropriate data operations or UI changes. Icons should enhance clarity.

### General Steps
1.  **Clear Labels**: Buttons and menu items should have descriptive labels (e.g., "Create User", "Edit User", "Delete User").
2.  **Icons**: Use relevant `lucide-react` icons (e.g., `Plus`, `Edit`, `Trash2`, `UserX`, `UserCheck`) to visually reinforce actions.
3.  **Dropdown Menus**: For multiple actions on a single item, use `DropdownMenu`.
4.  **Conditional Rendering**: Display actions conditionally based on data state (e.g., "Deactivate" for active users, "Activate" for inactive users).

### Example Application (User Actions in Table)
* **`users-table.tsx`**: The dropdown menu for each user row already demonstrates this principle, offering "Edit User", "View Profile", "Deactivate User", "Activate User", and "Delete User" options with corresponding icons. The conditional rendering for "Deactivate" vs. "Activate" is also a good example.

---

## Rule: Data Persistence (Simulated for Mock Data)

### Description
When performing CRUD operations with mock data, changes should be "persisted" by updating the source array in `data/` files directly via exported setter functions. This simulates a backend interaction for demonstration purposes.

### General Steps
1.  **Mutable Data Source**: Ensure your mock data arrays are mutable (e.g., `let users = [...]` and `export const setUsers = (newUsers) => { users = newUsers; };`).
2.  **Unique IDs**: Generate unique IDs for new items (e.g., `crypto.randomUUID()`).
3.  **Update in Place/Filter**: For updates, find and replace the object. For deletions, filter the array. For creations, append to the array.

### Example Application (All User CRUD Operations)
* **`data/users.ts`**: Will need to be modified to export a way to update the `users` array, perhaps like this:
    ```typescript
    export interface UserInterface { /* ... */ }

    export let users: UserInterface[] = [ /* initial data */ ];

    export const setUsers = (newUsers: UserInterface[]) => {
      users = newUsers;
      console.log("Users data updated:", users); // For debugging
    };
    ```
* **`page.tsx`**: Will call `setUsers` from `data/users.ts` (or manage `users` in its own state and pass it down) when a user is created, edited, deactivated, activated, or deleted.
